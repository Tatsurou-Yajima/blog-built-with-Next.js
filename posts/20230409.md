---
title: 'SQLアンチパターンの内容をまとめます その3'
date: '2023-04-09'
thumbnail: 'https://images-for-yajima-tech-blog.s3.amazonaws.com/sql-book-20230406.jpeg'
---

# SQLアンチパターンの内容をまとめます その3

![book](https://images-for-yajima-tech-blog.s3.amazonaws.com/sql-book-20230406.jpeg)

## 内容まとめ

## 16章 プアマンズ・サーチエンジン（貧者のサーチエンジン）

**全文検索で正規表現などを使用してしまう**アンチパターンです。

SQLで全文検索を実現するには、大きなコストを支払う必要があります。

### 解決策

**全文検索エンジン**を使いましょう！

有名どころだとElasticsearchがありますね。

[https://www.elastic.co/jp/elasticsearch/](https://www.elastic.co/jp/elasticsearch/)

他にもMySQLを拡張することでも実現可能です。

(InnoDB FULLTEXT インデックス)[https://dev.mysql.com/doc/refman/8.0/ja/innodb-fulltext-index.html]

## 17章 スパゲッティクエリ

**クエリが必要以上に複雑になってしまう**アンチパターンです。

### 解決策

クエリは、とにかくシンプルにしましょう！

本書の中では、頑張って1つのクエリにしようとして複雑になってしまったクエリを分割することで見違えるようにシンプルに再構成した例が紹介されていました。

## 18章 インプリシットカラム（暗黙の列）

**クエリの取得カラムにエイリアスをつけることを怠ったために、期待とは異なる結果になってしまう**、というアンチパターンです。

他にも、ワイルドカードを使うことでパフォーマンスとスケーラビリティが落ちる、ということも紹介されています。

### 解決策

列名を明示しましょう！

## 19章 リーダブルパスワード（読み取り可能パスワード）

**パスワードを平文で保持してしまう**アンチパターンです。

### 解決策

**ソルトを付けてパスワードハッシュを格納**しましょう！

単にハッシュ化するだけでなく、ソルトを付けることが推奨されています。

ソルトはユーザーごとに値を変えることでさらにセキュリティの強度が増します。

## 20章 SQLインジェクション

**ユーザーの入力値をクエリに組み込んでしまう**というアンチパターンです。

### 解決策

ユーザーの入力値は徹底してエスケープしましょう！

入力値をそのまま使うのは避けましょう。

他の開発者にコードレビューを依頼するのも有効です。

## 21章 シュードキー・ニートフリーク（擬似キー潔癖症）

**連番のIDの欠番を埋めてしまう**アンチパターンです。

連番を埋めることにより、様々な弊害が発生します。

外部キーなどを設定している場合は、いろいろな箇所に影響してしまいます。

### 解決策

擬似キーの欠番は埋めないようにしましょう！

もし上司に「欠番を埋めてくれ」と言われても、キッパリと断る意思を持ちましょう。

## 22章 シー・ノー・エビル（臭いものに蓋）

**システムからのメッセージ（エラーログなど）を見ない**というアンチパターンです。

### 解決策

エラーを確認しましょう！

デバッグにおいては、実際に実行されたクエリを出力してみるのが大切です。

## 23章 ディプロマティック・イミュニティ（外交特権）

**SQLを悪い意味で特別扱いしてしまう**というアンチパターンです。

例えば以下のようなベストプラクティスから、SQLを除外してしまうとアンチパターンとなります。

- バージョン管理
- CI/CD
- ドキュメント、コメントなどを残す

## 解決策

ベストプラクティスに従いましょう！

具体的には、**バージョン管理**、**テスティング**、**文書化**を行いましょう。

何を文書化するかというと、以下の通りです。

- ER図
- テーブル、列、ビュー
- トリガー
- ストアドプロシージャ
- SQLセキュリティ
- インフラ
- ORM

## 24 マジックビーンズ（魔法の豆）

**モデルがアクティブレコードそのものになってしまう**アンチパターンです。

思考停止で1テーブルに1モデルにしてしまうことで発生します。

マジックビーンズ状態だと、モデルのテストが難しくなります。

なぜなら、モデルがデータベースに依存してしまうためです。

### 解決策

モデルがアクティブレコードを持つ、という設計にしましょう！

必要に応じて、複数のアクティブレコードをモデルが保持する、という設計にすべきです。

モデルとテーブルは切り離して考えるべきです。

そうすることで、シンプルな設計が実現できます。

## 25章 砂の城

**想定が足りない**というアンチパターンです。

### 解決策

様々な事態を想定しておきましょう！

トラブルは起きるものと想定しておき、トラブルが起きた時どうするかも考えておきます。

具体的には、以下の処理を入れておくと良いでしょう。

- ベンチマーク
- 本番に限りなく近いテスト環境の構築
- 例外処理
- バックアップ
- 高可用性
- ディザスタリカバリ
- 運用ポリシーの策定

## おわりに

以上で本書の内容まとめを終わります。

その名の通り、SQLのアンチパターンが実例とともに紹介されており、とても勉強になりました。

マジックビーンズやIDリクワイアドなど、おそらく私もやってしまっているようなアンチパターンもあり、申し訳ない気持ちになりました！

以上です。
